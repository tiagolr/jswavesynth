desc: JSWavesynth
tags: synth, instrument

slider1:/tilr_JSWavesynth:Sine.wav:Wave
slider2:vol=-12<-90, 0, .01>Volume
slider3:maxpoly=8<0, 32, 1>Polyphony
slider4:uni_voices=2<1, 8, 1>Unison voices
slider5:uni_detune=0<0, 1, 0.01>Unison detune
slider6:uni_pan=0<0, 1, 0.01>Unison panning

import ws.wavetable.jsfx-inc
import ws.array.jsfx-inc

@init
lfile = -1;
lmaxpoly = -1;
wavebuf = 100000;
wavechn = 0;
wavelen = 0;
wavesrate = 0;
osc_free = 1;
poly.array_init(0, 128, 4+8); // [note, velocity, freq, phase, phase_unison1...phase_unison8, envelope]

function db2gain(db) (10^(db / 20););
function note2freq(n) ( 440 * pow(2, (n - 69) / 12); );

function normalize_wave(buf, len) (
  _min = 1;
  _max = -1;
  loop(i = 0; len,
    _min = min(_min, buf[i]);
    _max = max(_max, buf[i]);
    i += 1;
  );
  loop(i = 0; len,
    buf[i] = 2 * ((buf[i] - _min) / (_max - _min)) -1;
    i += 1;
  );
);

function stereo_to_mono_wave(buf, len) (
  i = 0; loop((len / 2) | 0,
    buf[i] = (buf[i*2] + buf[i*2+1]) * 0.5;
    i += 1;
  );
);

function on_file_change () (
  lfile = 0;
  filehandle=file_open(slider1);
  filehandle > 0 ? (
    lfile = slider1;
    file_riff(filehandle, wavechn, wavesrate);
    wavechn ? (
      wavelen = file_avail(filehandle);
      file_mem(filehandle,wavebuf,wavelen);
    );
    file_close(filehandle);
    wavechn == 2 ? (
      stereo_to_mono_wave(wavebuf, wavelen);
      wavelen = (wavelen / 2) | 0;
    );
    normalize_wave(wavebuf, wavelen);
    wave = 1;
    osc.wave_init(wavebuf, wavelen);
    osc.wave_setf(50);
  );
);

@slider

gain = db2gain(vol);
lfile != slider1 ? on_file_change();
lmaxpoly != maxpoly ? (
  lmaxpoly = maxpoly;
  poly.array_clear();
);
detune_amt = uni_detune * 3 / srate; // 3 hz max detune

@block

while (midirecv(offset, msg1, note, vel)) (
  event = msg1 & 0xF0;
  channel = msg1 & 0x0F;

  // Note on
  event == 0x90 && vel ? (

    // remove note if it is already playing
    ptr = poly.array_find(note);
    ptr >= 0 ? poly.array_remove(ptr);

    // if polyphony is full and not mono remove first element
    poly.size == maxpoly && maxpoly != 0 ? (
      poly.array_remove(poly.array_first());
    );

    ptr = poly.array_add();
    ptr[0] = note;
    ptr[1] = vel / 127;
    ptr[2] = note2freq(note) / srate;
    ptr[3] = osc_free ? rand(2) - 1 : 0; // osc start phase
    loop(i = 4; 8,
      ptr[i] = osc_free ? rand(2) - 1 : 0; // random unison start phase
      i += 1;
    );
  );

  // Note off
  event == 0x80 || (event == 0x90 && !vel) ? (
    ptr = poly.array_find(note);
    ptr >= 0 ? poly.array_remove(ptr);
  );

  // All notes off
  event == 0xB0 && note == 123 ? (
    poly.array_clear();
  );

  midisend(offset, msg1, note, vel);
);

@sample

lfile >= 0 ? (
  outl = 0;
  outr = 0;
  odd_voices = uni_voices & 1;
  ptr = maxpoly == 0
    ? poly.array_last() /* mono voicing */
    : poly.array_first();
  while(ptr >= 0) (
    loop(i = 0; uni_voices | 0,
      imod2 = i & 1;
      pos = i == 0 && odd_voices ? 0 : imod2 ? -1 : 1; // center, left or right position
      detune = !odd_voices
        ? pos * detune_amt * (i + 1 - imod2) / uni_voices
        : pos * detune_amt * (i + imod2) / uni_voices;
      osc.wave_setdt(ptr[2] + detune);
      osc.wave_sync(ptr[i + 3]);
      wave = osc.wave_spline3();
      pan = !odd_voices
        ? pos * uni_pan * (i + 1 - imod2) / uni_voices
        : pos * uni_pan * (i + imod2) / uni_voices;
      outl += wave * (1 + pan);
      outr += wave * (1 - pan);
      ptr[i + 3] = osc.t; // update osc phase
      i += 1;
    );

    ptr = poly.array_next(ptr);
  );
  spl0 += outl * gain;
  spl1 += outr * gain;
  //spl0 = spl1 = osc.wave_spline3() * gain;
);
